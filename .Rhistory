(pi - 1)*pi = (epsilon/phi_p)*(mc - (epsilon-1)/epsilon) +
beta*(lambda(+1)/lambda)*(Y(+1)/Y)*(pi(+1)-1)*pi(+1);
Pi_real = Y - r_k*K(-1) - w*h - (phi_p/2)*(pi - 1)^2*Y;
// Government
g + R(-1)*(b(-1)/pi) = b + tau;
tau = (1 - rho_tau)*tau_ss + rho_tau*tau(-1) + epsilon_tau;
g = (1 - rho_g)*g_ss + rho_g*g(-1) + epsilon_g;
// Monetary policy
R = rho_R*R(-1) + (1 - rho_R)*(1/beta + phi_pi*(pi - pi_ss) +
phi_y*((Y - Y_ss)/Y_ss)) + epsilon_R;
// Market clearing
%Y = c + i + g + (phi_k/2)*(i/K(-1) - delta)^2*K(-1) +
(phi_p/2)*(pi - 1)^2*Y;
K = (1 - delta)*K(-1) + i - (phi_k/2)*(i/K(-1) - delta)^2*K(-1);
// Exogenous processes
log(A) = rho_a*log(A(-1)) + epsilon_a;
end;
// Steady-state initialization (solved numerically)
initval;
pi = pi_ss;
R = 1/beta;
r_k = 1/beta - (1 - delta);
mc = (epsilon-1)/epsilon;
A = 1;
h = 0.3;          // Initial guess
Y = (A*(alpha*mc/r_k)^alpha*h^(1-alpha))^(1/(1-alpha));
K = alpha*mc*Y/r_k;
i = delta*K;
g = g_ss*Y;
tau = tau_ss*Y;
c = Y - i - g;
w = mc*(1-alpha)*Y/h;
lambda = (c*(1-eta))^(-theta)*(1 - beta*eta);
mu = lambda;
m = psi/(lambda*(1 - beta));
b = 0;
Pi_real = Y - r_k*K - w*h;
end;
steady;  // Numerically solve for steady state
// Shocks (adjust magnitudes as needed)
shocks;
var epsilon_R; stderr 0.01;   // Monetary policy shock
var epsilon_a; stderr 0.01;   // Technology shock
var epsilon_g; stderr 0.01;   // Gov spending shock
var epsilon_tau; stderr 0.01; // Tax shock
end;
stoch_simul(order=1, irf=20, periods=1000);
"
# will set eval to true when happy with MOD file
write_mod(
code  = dynareCodes_NKM,
model = "code/nkm_model"
)
nkm_results <- run_dynare(
code       = dynareCodes_NKM,    # <— correct name here
model      = "code/nkm_model",
import_log = TRUE)
dynare$nkm_model$steady
#Please note that this is not the correct mod file, but here for example purposes based on what i have currently
dynareCodes_NKM <- "// DSGE Model based on Liam Andrew Beattie's Macroeconomics Assignment
var c i g b m w r_k mc Y h K pi lambda mu R tau Pi_real A;
varexo epsilon_g epsilon_tau epsilon_a epsilon_R;
parameters beta theta eta chi gamma psi delta phi_k alpha epsilon phi_p
rho_R phi_pi phi_y rho_g rho_tau rho_a pi_ss g_ss tau_ss Y_ss;
// Parameter calibration (adjust as needed)
beta = 0.99;     // Discount factor
theta = 2.0;     // Relative risk aversion
eta = 0.7;       // Habit persistence
chi = 1.0;       // Labor disutility weight
gamma = 1.0;     // Inverse Frisch elasticity
psi = 0.1;       // Money utility weight
delta = 0.025;   // Depreciation rate
phi_k = 0.5;     // Capital adjustment cost
alpha = 0.33;    // Capital share
epsilon = 6.0;   // Elasticity of substitution (goods)
phi_p = 50.0;    // Price adjustment cost
rho_R = 0.7;     // Interest rate smoothing
phi_pi = 1.5;    // Taylor rule (inflation)
phi_y = 0.5;     // Taylor rule (output gap)
rho_g = 0.9;     // Gov spending persistence
rho_tau = 0.9;   // Tax persistence
rho_a = 0.9;     // TFP persistence
pi_ss = 1.0;     // Steady-state inflation
g_ss = 0.2;      // Steady-state gov spending (share)
tau_ss = 0.2;    // Steady-state taxes (share)
Y_ss = 1.0;      // Steady-state output (normalized)
model;
// Households
lambda = (c - eta*c(-1))^(-theta) - beta*eta*(c(+1) - eta*c)^(-theta);
lambda*w = chi*h^gamma;
psi/m = lambda - beta*(lambda(+1)/pi(+1));
lambda = beta*(lambda(+1)/pi(+1))*R;
lambda = mu*(1 - phi_k*(i/K(-1) - delta));
mu = beta*(lambda(+1)*r_k(+1) + mu(+1)*((1-delta) +
(phi_k/2)*((i(+1)/K)^2 - delta^2)));
// Firms
Y = A*K(-1)^alpha*h^(1-alpha);
r_k = mc*alpha*Y/K(-1);
w = mc*(1-alpha)*Y/h;
mc = (1/A)*((r_k/alpha)^alpha*(w/(1-alpha))^(1-alpha));
(pi - 1)*pi = (epsilon/phi_p)*(mc - (epsilon-1)/epsilon) +
beta*(lambda(+1)/lambda)*(Y(+1)/Y)*(pi(+1)-1)*pi(+1);
Pi_real = Y - r_k*K(-1) - w*h - (phi_p/2)*(pi - 1)^2*Y;
// Government
g + R(-1)*(b(-1)/pi) = b + tau;
tau = (1 - rho_tau)*tau_ss + rho_tau*tau(-1) + epsilon_tau;
g = (1 - rho_g)*g_ss + rho_g*g(-1) + epsilon_g;
// Monetary policy
R = rho_R*R(-1) + (1 - rho_R)*(1/beta + phi_pi*(pi - pi_ss) +
phi_y*((Y - Y_ss)/Y_ss)) + epsilon_R;
// Market clearing
% Y = c + i + g + (phi_k/2)*(i/K(-1) - delta)^2*K(-1) + (phi_p/2)*(pi - 1)^2*Y;
K = (1 - delta)*K(-1) + i - (phi_k/2)*(i/K(-1) - delta)^2*K(-1);
// Exogenous processes
log(A) = rho_a*log(A(-1)) + epsilon_a;
end;
// Steady-state initialization (solved numerically)
initval;
pi = pi_ss;
R = 1/beta;
r_k = 1/beta - (1 - delta);
mc = (epsilon-1)/epsilon;
A = 1;
h = 0.3;          // Initial guess
Y = (A*(alpha*mc/r_k)^alpha*h^(1-alpha))^(1/(1-alpha));
K = alpha*mc*Y/r_k;
i = delta*K;
g = g_ss*Y;
tau = tau_ss*Y;
c = Y - i - g;
w = mc*(1-alpha)*Y/h;
lambda = (c*(1-eta))^(-theta)*(1 - beta*eta);
mu = lambda;
m = psi/(lambda*(1 - beta));
b = 0;
Pi_real = Y - r_k*K - w*h;
end;
steady;  // Numerically solve for steady state
// Shocks (adjust magnitudes as needed)
shocks;
var epsilon_R; stderr 0.01;   // Monetary policy shock
var epsilon_a; stderr 0.01;   // Technology shock
var epsilon_g; stderr 0.01;   // Gov spending shock
var epsilon_tau; stderr 0.01; // Tax shock
end;
stoch_simul(order=1, irf=20, periods=1000);
"
# will set eval to true when happy with MOD file
write_mod(
code  = dynareCodes_NKM,
model = "code/nkm_model"
)
nkm_results <- run_dynare(
code       = dynareCodes_NKM,    # <— correct name here
model      = "code/nkm_model",
import_log = TRUE)
#Please note that this is not the correct mod file, but here for example purposes based on what i have currently
dynareCodes_NKM <- "% DSGE Model with Real Variables
% Adapted from provided equations
var c i b m h k pi w rk lambda mu mc y g tau R a;
varexo epsilon_R epsilon_tau epsilon_g epsilon_a;
parameters
beta eta theta chi gamma delta phi_k phi_p psi alpha epsilon
rho_R rho_tau rho_g rho_a phi_pi phi_y pi_star R_star y_ss g_bar tau_bar;
% Parameter Calibration (adjust as needed)
beta = 0.99;     % Discount factor
eta = 0.5;       % Habit persistence
theta = 2;       % Inverse elasticity of substitution
chi = 1;         % Labor disutility coefficient
gamma = 2;       % Inverse Frisch elasticity
delta = 0.025;   % Depreciation rate
phi_k = 2;       % Investment adjustment cost
phi_p = 100;     % Price adjustment cost
psi = 0.01;      % Utility weight on money
alpha = 0.3;     % Capital share in production
epsilon = 6;     % Elasticity of substitution (goods)
rho_R = 0.8;     % Taylor rule inertia
rho_tau = 0.8;   % Tax persistence
rho_g = 0.8;     % Gov spending persistence
rho_a = 0.9;     % Technology persistence
phi_pi = 1.5;    % Inflation response in Taylor rule
phi_y = 0.125;   % Output response in Taylor rule
pi_star = 1;     % Target inflation (gross)
g_bar = 0.2;     % Steady-state gov spending
tau_bar = 0.2;   % Steady-state taxes
y_ss = 1;        % Steady-state output (normalized)
R_star = pi_star / beta;  % Steady-state nominal interest rate
model;
// 1. Capital accumulation
k = (1 - delta)*k(-1) + i - (phi_k/2)*(i/k(-1) - delta)^2*k(-1);
// 2. FOC consumption (habit-adjusted)
lambda = (c - eta*c(-1))^(-theta) - beta*eta*(c(+1) - eta*c)^(-theta);
// 3. FOC labor
lambda*w = chi*h^gamma;
// 4. FOC money (real balances)
psi/m = lambda - beta*(lambda(+1)/pi(+1));
// 5. FOC bonds
lambda = beta*lambda(+1)*(R/pi(+1));
// 6. FOC investment
lambda = mu*(1 - phi_k*(i/k(-1) - delta));
// 7. FOC capital
mu = beta*(
lambda(+1)*rk(+1) +
mu(+1)*(
(1 - delta) +
(phi_k/2)*((i(+1)/k)^2 - delta^2)
)
);
// 8. Production function
y = exp(a)*(k(-1)^alpha)*(h^(1 - alpha));
// 9. Capital demand
rk = mc*alpha*exp(a)*(k(-1)^(alpha - 1))*(h^(1 - alpha));
// 10. Labor demand
w = mc*(1 - alpha)*exp(a)*(k(-1)^alpha)*(h^(-alpha));
// 11. NK Phillips Curve
(pi - 1)*pi = (epsilon/phi_p)*(mc - (epsilon - 1)/epsilon) +
beta*(lambda(+1)/lambda)*(y(+1)/y)*(pi(+1) - 1)*pi(+1);
// 12. Government budget constraint
g + (R(-1)/pi)*b(-1) = b + tau;
// 13. Taylor rule (log-linear output gap)
R = rho_R*R(-1) + (1 - rho_R)*(R_star + phi_pi*(pi - pi_star) +
phi_y*(log(y) - log(y_ss))) + epsilon_R;
// 14. Tax process
tau = (1 - rho_tau)*tau_bar + rho_tau*tau(-1) + epsilon_tau;
// 15. Government spending process
g = (1 - rho_g)*g_bar + rho_g*g(-1) + epsilon_g;
// 16. Technology process
a = rho_a*a(-1) + epsilon_a;
// 17. Resource constraint
y = c + i + g + (phi_k/2)*(i/k(-1) - delta)^2*k(-1) +
(phi_p/2)*(pi - 1)^2*y;
end;
initval;
// Initialize near steady state (exact values computed below)
c = 0.6;
i = 0.2;
b = 0;
m = 0.1;
h = 0.3;
k = 8;
pi = pi_star;
w = 2;
rk = (1/beta) - (1 - delta);
lambda = (c - eta*c)^(-theta) - beta*eta*(c - eta*c)^(-theta); // SS approx
mu = 1;
mc = (epsilon - 1)/epsilon; // Flexible-price steady state
y = y_ss;
g = g_bar;
tau = tau_bar;
R = R_star;
a = 0;
end;
steady; // Computes steady state numerically
shocks;
var epsilon_R = 0.01^2;    % Monetary policy shock
var epsilon_tau = 0.01^2;  % Tax shock
var epsilon_g = 0.01^2;    % Gov spending shock
var epsilon_a = 0.01^2;    % Technology shock
end;
stoch_simul(order=1, irf=20) y c i h pi R;
"
# will set eval to true when happy with MOD file
write_mod(
code  = dynareCodes_NKM,
model = "code/nkm_model"
)
nkm_results <- run_dynare(
code       = dynareCodes_NKM,    # <— correct name here
model      = "code/nkm_model",
import_log = TRUE)
dynare$nkm_model$steady
#Please note that this is not the correct mod file, but here for example purposes based on what i have currently
dynareCodes_NKM <- "// Model: DSGE with Capital, Money, and Sticky Prices
// Endogenous Variables
var pi c i b m K h Y g tau A mc w r_k R lambda_real mu;
varexo eR e_tau e_g e_a;
// Parameters
parameters beta eta theta chi gamma psi delta phi_k alpha epsilon phi_p
rho_R phi_pi phi_y rho_tau rho_g rho_a
pi_ss R_ss Y_ss tau_ss g_ss A_ss;
// Parameter Calibration (example values - adjust as needed)
beta = 0.99;       // Discount factor
eta = 0.5;         // Habit persistence
theta = 2;         // Risk aversion
chi = 1;           // Labor disutility weight
gamma = 1.5;       // Inverse Frisch elasticity
psi = 0.01;        // Money utility weight
delta = 0.025;     // Depreciation rate
phi_k = 4;         // Investment adjustment cost
alpha = 0.33;      // Capital share
epsilon = 6;       // Elasticity of substitution
phi_p = 20;        // Price adjustment cost
rho_R = 0.8;       // Taylor rule inertia
phi_pi = 1.5;      // Inflation response
phi_y = 0.125;     // Output response
rho_tau = 0.9;     // Tax persistence
rho_g = 0.9;       // Gov spending persistence
rho_a = 0.9;       // Tech persistence
pi_ss = 1.0;       // Steady-state inflation
Y_ss = 1.0;        // Steady-state output (normalized)
tau_ss = 0.2;      // Steady-state taxes
g_ss = 0.2;        // Steady-state gov spending
A_ss = 1.0;        // Steady-state technology
// Steady-State Calculations
R_ss = pi_ss / beta;                   // Nominal rate (eq 26)
r_k_ss = (1/beta) - (1 - delta);       // Real return on capital (eq 27)
model;
// Inflation Definition (eq 1)
pi = P / P(-1);
// Capital Accumulation (eq 3)
K = (1 - delta)*K(-1) + i - (phi_k/2)*((i/K(-1)) - delta)^2 * K(-1);
// Aggregate Production (eq 11)
Y = A * K(-1)^alpha * h^(1 - alpha);
// Real Marginal Cost (eq 16)
mc = (1/A) * (r_k/alpha)^alpha * (w/(1 - alpha))^(1 - alpha);
// New Keynesian Phillips Curve (eq 17)
(pi - 1)*pi = (epsilon/phi_p) * (mc - (epsilon - 1)/epsilon)
+ beta * (lambda_real(1)/lambda_real) * (Y(1)/Y) * (pi(1) - 1);
// Government Budget Constraint (eq 18, real)
g + R(-1)*b(-1)/pi = b + tau;
// Taylor Rule (eq 21)
R = rho_R*R(-1) + (1 - rho_R)*(R_ss + phi_pi*(pi - pi_ss) + phi_y*((Y - Y_ss)/Y_ss)) + eR;
// Resource Constraint (eq 22)
Y = c + i + g + (phi_k/2)*((i/K(-1)) - delta)^2 * K(-1) + (phi_p/2)*(pi - 1)^2 * Y;
// Tax Process (eq 23)
tau = (1 - rho_tau)*tau_ss + rho_tau*tau(-1) + e_tau;
// Government Spending (eq 24)
g = (1 - rho_g)*g_ss + rho_g*g(-1) + e_g;
// Technology Process (eq 25)
log(A) = rho_a*log(A(-1)) + e_a;
// FOC Consumption (eq 4)
lambda_real = (c - eta*c(-1))^(-theta) - beta*eta*((c(1) - eta*c)^(-theta));
// FOC Labor (eq 5)
lambda_real * w = chi * h^gamma;
// FOC Money (eq 6)
psi / m = lambda_real - beta*(lambda_real(1)/pi(1));
// FOC Bonds (eq 7 + 20)
lambda_real = beta*(lambda_real(1)/pi(1)) * R;
// FOC Investment (eq 8)
lambda_real = mu * (1 - phi_k*((i/K(-1)) - delta));
// FOC Capital (eq 9)
mu = beta * (lambda_real(1)*r_k(1)
+ mu(1) * ((1 - delta) + (phi_k/2)*((i(1)/K)^2 - delta^2)));
end;
// Steady-State Initialization (example - solve numerically)
initval;
pi = pi_ss;
R = R_ss;
r_k = r_k_ss;
Y = Y_ss;
c = Y_ss * 0.6;  // Adjust to satisfy constraints
i = Y_ss * 0.2;
g = g_ss;
tau = tau_ss;
A = A_ss;
K = (alpha * Y_ss * mc / r_k)^(1/(1 - alpha));  // From prod. function
h = ((1 - alpha) * Y_ss * mc / w)^(1/alpha) * K;
w = (1 - alpha) * mc * (K/h)^alpha * A;
mc = (epsilon - 1)/epsilon;  // Zero inflation SS
b = 0.6;  // Debt/GDP ratio
m = (psi * c^theta) / (1 - beta/pi_ss);  // Money demand
lambda_real = (c*(1 - eta))^(-theta);  // Habit-adjusted MU
mu = lambda_real / (1 - phi_k*(delta - delta));  // Adj. cost=0 in SS
end;
steady;  // Solve for steady state
// Shocks
shocks;
var eR = 0.01^2;       // Monetary policy shock
var e_tau = 0.01^2;    // Tax shock
var e_g = 0.01^2;      // Government spending shock
var e_a = 0.01^2;      // Technology shock
end;
// Solution
stoch_simul(order=1, irf=20);
"
# will set eval to true when happy with MOD file
write_mod(
code  = dynareCodes_NKM,
model = "code/nkm_model"
)
nkm_results <- run_dynare(
code       = dynareCodes_NKM,    # <— correct name here
model      = "code/nkm_model",
import_log = TRUE)
dynare$nkm_model$steady
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 5, fig.pos="H", fig.pos = 'H')
# Note: Include = FALSE implies the code is executed, but not printed in your pdf.
# warning and message = FALSE implies ugly messages and warnings are removed from your pdf.
# These should be picked up when you execute the command chunks (code sections below) in your rmd, not printed in your paper!
# Lets load in example data, and see how this can be stored and later called from your 'data' folder.
if(!require("tidyverse")) install.packages("tidyverse")
library(tidyverse)
library(DynareR)
#Please note that this is not the correct mod file, but here for example purposes based on what i have currently
dynareCodes_NKM <- "// DSGE Model with Sticky Prices and Capital Adjustment Costs
var pi c i g d m w rk K Pi_r lambda mu Y mc R h tau A Y_star;
varexo e_R e_tau e_g e_a;
parameters beta theta eta chi gamma psi delta phi_k phi_p epsilon alpha
rho_R R_star pi_star kappa_pi kappa_y rho_tau tau_bar rho_g g_bar rho_a;
// Parameter Calibration (adjust as needed)
beta = 0.99;       // Discount factor
theta = 2.0;       // Risk aversion
eta = 0.7;         // Habit persistence
chi = 1.0;         // Labor disutility weight
gamma = 2.0;       // Inverse Frisch elasticity
psi = 0.01;        // Money demand shifter
delta = 0.025;     // Depreciation rate
phi_k = 4.0;       // Capital adjustment cost
phi_p = 100.0;     // Price adjustment cost
epsilon = 6.0;     // Elasticity of substitution
alpha = 0.33;      // Capital share
rho_R = 0.8;       // Taylor rule persistence
pi_star = 1.0;     // Target inflation
R_star = 1/beta;   // Steady-state nominal rate
kappa_pi = 1.5;    // Inflation response
kappa_y = 0.125;   // Output response (0.5/4 for quarterly)
rho_tau = 0.9;     // Tax persistence
tau_bar = 0.2;     // Steady-state taxes
rho_g = 0.9;       // Gov spending persistence
g_bar = 0.2;       // Steady-state gov spending
rho_a = 0.9;       // TFP persistence
model;
// Household Budget Constraint (eq.3)
c + i + d + m = R(-1)*d(-1) + m(-1)/pi + w*h + rk*K(-1) + Pi_r - tau;
// Capital Accumulation (eq.4)
K = (1 - delta)*K(-1) + i - (phi_k/2)*((i/K(-1)) - delta)^2*K(-1);
// Firm Profits (eq.5)
Pi_r = Y - rk*K(-1) - w*h - (phi_p/2)*(pi - 1)^2*Y;
// FOC Consumption (eq.6)
lambda = (c - eta*c(-1))^(-theta) - beta*eta*(c(+1) - eta*c)^(-theta);
// FOC Labor (eq.7)
lambda*w = chi*h^gamma;
// FOC Bonds (eq.8)
lambda = beta*lambda(+1)*R;
// FOC Money (eq.9)
psi/m = lambda - beta*lambda(+1)/pi(+1);
// FOC Investment (eq.10)
lambda = mu*(1 - phi_k*((i/K(-1)) - delta));
// FOC Capital (eq.11)
mu = beta*(lambda(+1)*rk(+1) + mu(+1)*((1 - delta) -
(phi_k/2)*(delta^2 - (i(+1)/K)^2)));
// Aggregate Production (eq.28)
Y = A*K(-1)^alpha*h^(1 - alpha);
// Marginal Cost (eq.15)
mc = (1/A)*(rk/alpha)^alpha*(w/(1 - alpha))^(1 - alpha);
// NK Phillips Curve (eq.16)
(pi - 1)*pi = (epsilon/phi_p)*(mc - (epsilon - 1)/epsilon) +
beta*(lambda(+1)/lambda)*(Y(+1)/Y)*(pi(+1) - 1)*pi(+1);
// Government Budget (eq.17)
g + R(-1)*d(-1) = d + tau;
// Resource Constraint (eq.18)
Y = c + i + g + (phi_k/2)*((i/K(-1)) - delta)^2*K(-1) +
(phi_p/2)*(pi - 1)^2*Y;
// Taylor Rule (eq.20)
R = rho_R*R(-1) + (1 - rho_R)*(R_star + kappa_pi*(pi - pi_star) +
kappa_y*((Y - Y_star)/Y_star)) + e_R;
// Tax Process (eq.25)
tau = (1 - rho_tau)*tau_bar + rho_tau*tau(-1) + e_tau;
// Government Spending (eq.26)
g = (1 - rho_g)*g_bar + rho_g*g(-1) + e_g;
// Technology (eq.27)
log(A) = rho_a*log(A(-1)) + e_a;
// Steady-State Output (for Taylor rule)
Y_star = Y_star(-1);
end;
steady_state_model;
// Solve for steady state
pi = pi_star;
A = 1;
R = R_star;
mc = (epsilon - 1)/epsilon;
rk = (1 - beta*(1 - delta))/beta;
khr = (rk/(mc*alpha))^(1/(alpha - 1));  // K/h ratio
w = mc*(1 - alpha)*khr^alpha;
d = 0;  // Steady-state debt = 0
gy = g_bar;  // g/Y ratio (calibrate to g_bar)
// Solve for h
c_constant = khr^alpha*(1 - gy) - delta*khr;
h = ((w*(1 - beta*eta))/(chi*c_constant^(-theta)*(1 - eta)^(-theta)))^(1/(gamma - theta));
// Compute steady-state values
Y = khr^alpha*h;
i = delta*khr*h;
g = gy*Y;
tau = g;  // Since d=0
c = c_constant*h;
lambda = (c*(1 - eta))^(-theta)*(1 - beta*eta);
mu = lambda;
m = psi/(lambda*(1 - beta));
K = khr*h;
Pi_r = Y - rk*K - w*h;  // Price adj cost=0 at SS
Y_star = Y;  // Initialize steady-state output
end;
shocks;
var e_R = 0.01^2;     // Monetary policy shock
var e_tau = 0.01^2;   // Tax shock
var e_g = 0.01^2;     // Spending shock
var e_a = 0.01^2;     // Technology shock
end;
steady;
check;
stoch_simul(order=1, irf=20, periods=0);
"
# will set eval to true when happy with MOD file
write_mod(
code  = dynareCodes_NKM,
model = "code/nkm_model"
)
nkm_results <- run_dynare(
code       = dynareCodes_NKM,    # <— correct name here
model      = "code/nkm_model",
import_log = TRUE)
dynare$nkm_model$steady
